import re

def add_labels(content, counter):
    labeled_content = f'.LABEL {counter}\n'
    labeled_content += f'SELECT \'{counter}\' as lg_delete\n'
    labeled_content += f'{content.strip()}\n'
    return labeled_content, counter + 1

# Path to the script file
script_path = 'C:\\Users\\id\\Desktop\\script.sql'

# Read the script content from the file
with open(script_path, 'r') as file:
    script_content = file.read()

# Split the script content into individual statements
statements = re.split(r';\s*', script_content.strip())

# Initialize variables
counter = 1
volatile_tables = set()
labeled_statements = []
current_block = []
inside_volatile_block = False

# Patterns for volatile and permanent table creation
volatile_pattern = re.compile(r'CREATE\s+(MULTISET\s+)?VOLATILE\s+TABLE\s+(\w+)', re.IGNORECASE)
permanent_pattern = re.compile(r'CREATE\s+(MULTISET\s+)?PERMANENT\s+TABLE\s+\w+\.\w+', re.IGNORECASE)
table_usage_pattern = re.compile(r'(\b\w+\b)')

# First pass: Identify all volatile tables
for statement in statements:
    statement = statement.strip()
    if not statement:
        continue
    match = volatile_pattern.search(statement)
    if match:
        table_name = match.group(2)
        volatile_tables.add(table_name.lower())
        print(f"Identified volatile table: {table_name.lower()}")

# Debug: Print all identified volatile tables
print(f"Volatile tables: {volatile_tables}")

# Second pass: Process and label statements
for statement in statements:
    statement = statement.strip()
    if not statement:
        continue
    
    # Check if the statement creates a volatile table
    if volatile_pattern.search(statement):
        # If creating a volatile table, ensure that current block is labeled
        if current_block:
            if inside_volatile_block:
                labeled_block, counter = add_labels('\n'.join(current_block), counter)
                labeled_statements.append(labeled_block)
            else:
                labeled_statements.append('\n'.join(current_block))
            current_block = []
        # Start a new block with the volatile table creation
        current_block.append(statement)
        inside_volatile_block = True
        print(f"Labeled volatile table creation: {statement}")
    
    else:
        # Check if the statement depends on any volatile tables
        tables_in_statement = table_usage_pattern.findall(statement.lower())
        if any(table in volatile_tables for table in tables_in_statement):
            # If the statement depends on a volatile table, add it to the current block
            current_block.append(statement)
            print(f"Statement depends on volatile table: {statement}")
            inside_volatile_block = True
        else:
            # If the statement does not depend on a volatile table
            if inside_volatile_block:
                # Label the current block before starting a new one
                labeled_block, counter = add_labels('\n'.join(current_block), counter)
                labeled_statements.append(labeled_block)
                current_block = []
                inside_volatile_block = False
            # Add the independent statement to a new block
            current_block.append(statement)
            print(f"Independent statement: {statement}")
            if permanent_pattern.search(statement):
                # If it is a permanent table, label immediately
                labeled_block, counter = add_labels('\n'.join(current_block), counter)
                labeled_statements.append(labeled_block)
                current_block = []

# Label any remaining statements in the current block
if current_block:
    if inside_volatile_block:
        labeled_block, counter = add_labels('\n'.join(current_block), counter)
    else:
        labeled_block = '\n'.join(current_block)
    labeled_statements.append(labeled_block)

# Debug: Print all labeled statements
print(f"Labeled statements: {labeled_statements}")

# Add a semicolon after each labeled statement except for the last one
labeled_script = ';\n'.join(labeled_statements) + ';'

# Path to save the modified script
output_path = 'C:\\Users\\id\\Desktop\\enablers1_labeled.sql'

# Write the modified script to a new file
with open(output_path, 'w') as file:
    file.write(labeled_script)
